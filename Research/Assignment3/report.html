<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nicole Yazbeck, Yosi Assefa, Kevin Hwangpo, Kelly Hwangpo, Zerlyne N-Simons">
<meta name="dcterms.date" content="2025-03-29">

<title>AI Applied to Coding</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link active" data-scroll-target="#table-of-contents">Table of Contents</a></li>
  <li><a href="#introduction-using-ai-in-coding-1" id="toc-introduction-using-ai-in-coding-1" class="nav-link" data-scroll-target="#introduction-using-ai-in-coding-1">Introduction: Using AI in Coding</a></li>
  <li><a href="#state-of-the-art-research-ai-tools-applied-to-coding-1" id="toc-state-of-the-art-research-ai-tools-applied-to-coding-1" class="nav-link" data-scroll-target="#state-of-the-art-research-ai-tools-applied-to-coding-1">State-of-the-Art Research: AI Tools Applied to Coding</a></li>
  <li><a href="#important-tools-1" id="toc-important-tools-1" class="nav-link" data-scroll-target="#important-tools-1">Important Tools</a></li>
  <li><a href="#emerging-tools-1" id="toc-emerging-tools-1" class="nav-link" data-scroll-target="#emerging-tools-1">Emerging Tools</a></li>
  <li><a href="#sources" id="toc-sources" class="nav-link" data-scroll-target="#sources">Sources</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AI Applied to Coding</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Nicole Yazbeck, Yosi Assefa, Kevin Hwangpo, Kelly Hwangpo, Zerlyne N-Simons </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 29, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><img src="aiappliedtocoding.png" class="img-fluid" style="border-radius: 15px; box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2); display: block; margin: auto;"></p>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<section id="introduction-using-ai-in-coding" class="level4">
<h4 class="anchored" data-anchor-id="introduction-using-ai-in-coding">Introduction: Using AI in Coding</h4>
<blockquote class="blockquote">
<p>An overview of how AI is impacting the world of coding and how it is changing the job of software developers.</p>
</blockquote>
</section>
<section id="state-of-the-art-research-ai-tools-applied-to-coding" class="level4">
<h4 class="anchored" data-anchor-id="state-of-the-art-research-ai-tools-applied-to-coding">State-of-the-Art Research: AI Tools Applied to Coding</h4>
<blockquote class="blockquote">
<p>A review of the latest research and innovations in AI tools that assist in the coding of software. This will highlight the newest studies and upcoming innovations in AI-assisted coding.</p>
</blockquote>
</section>
<section id="important-tools" class="level4">
<h4 class="anchored" data-anchor-id="important-tools">Important Tools</h4>
<blockquote class="blockquote">
<p>A detailed description of the current widely-used AI tools and technologies for coding. This section explores established AI tools and platforms that aid in automating and enhancing the process of coding while highlighting their strengths and weaknesses.</p>
</blockquote>
</section>
<section id="emerging-tools" class="level4">
<h4 class="anchored" data-anchor-id="emerging-tools">Emerging Tools</h4>
<blockquote class="blockquote">
<p>A look at emerging AI tools and technologies that are starting to gain traction in the field of coding. This section discusses the potential of these new tools and how these tools could impact coding for years to come.</p>
</blockquote>
<div class="page-break">

</div>
</section>
</section>
<section id="introduction-using-ai-in-coding-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-using-ai-in-coding-1">Introduction: Using AI in Coding</h2>
<p>Artificial intelligence in the world of software engineering raises both concerns and hopeful expectations for the future. As AI continues to advance, we quickly learned that AI can process and develop code faster but as accurately as the human mind. However, this questions the jobs of software engineers will be overtaken and replaced by AI. Found by research from the article, “AI And The Future Of Coding”, thirty percent of all coding has already been developed by AI. On the other hand, many deny this theory, as they believe that some code requires more creative, less generic writing. Most codes that need human attention cannot be skewed or at risk through AI generated works because of the lack of security. But aside from these different opinions, we know for a fact that because AI has become more accessible to the public; many can develop and gain opportunities from simple technical software coding AI can produce. As of now, we can only watch AI grow and see where the future of technology according to AI takes us.</p>
</section>
<section id="state-of-the-art-research-ai-tools-applied-to-coding-1" class="level2">
<h2 class="anchored" data-anchor-id="state-of-the-art-research-ai-tools-applied-to-coding-1">State-of-the-Art Research: AI Tools Applied to Coding</h2>
<div class="page-break">

</div>
</section>
<section id="important-tools-1" class="level2">
<h2 class="anchored" data-anchor-id="important-tools-1">Important Tools</h2>
<p>There are a myriad of AI tools out there for software developers which work to streamline development and assist developers in creating high-quality software projects. In this section, we are going to focus on three of those tools and compare their strengths and their weaknesses. First, we are going to discuss ChatGPT. This conversational AI assistant is one of the most widely used AI tools across various fields. ChatGPT surpasses other models when it comes to providing developers with thorough code explanations. This model is a go-to when you just need quick information on external libraries or need a more in-depth understanding on a piece of code that may look confusing or intimidating starting out. One major pitfall when using ChatGPT, is its inability to flow seamlessly with the development process. It can be quite annoying to have to go to and from the coding editor when you need assistance. The next AI-powered tool we are going to talk about is Tabnine. This tool works seamlessly with numerous IDEs making it an ideal choice for developers. Tabnine excels at auto-completing functions, identifying potential errors and generating test cases in order to help developers create more efficient and accurate code. However, its chat functionality is sometimes not very accurate and it can have trouble implementing proper error handling in its auto-completed functions. Additionally, the test cases often lack complexity which can mean they need more human refining and enhancements. Another important AI-powered coding tool that deserves a mention is GitHub CoPilot. This tool has many helpful capabilities to aid in the development process from auto-completion to test case generation. It is very similar to Tabnine in its functionality, however, it has been known to provide more thorough and accurate responses when it comes to error handling and test case creation. However, like many AI-powered assistants even if it provides a correct solution it may not always be the most effective solution. In conclusion, all of the tools discussed work to improve the efficiency and quality of a developers time, however, as a developer it is important to always evaluate code given from AI coding assistants to determine if it will fit the needs of your program.</p>
</section>
<section id="emerging-tools-1" class="level2">
<h2 class="anchored" data-anchor-id="emerging-tools-1">Emerging Tools</h2>
<p>There are numerous emerging AI tools used to transform the coding industry by enhancing productivity and automating various aspects of software development. Some tools include Google’s Gemini 2.5 Pro which is an advanced AI model that excels in reasoning abilities by combining “a significantly enhanced base model with improved post-training.” It processes tasks step-by-step and makes more informed decisions by supporting multi-model inputs like text and code. Microsoft 365 Copilot’s Researcher and Analyst Agents are “deep reasoning” AI agents that assist in research and data analysis tasks. “Researcher” relies on OpenAI’s deep research AI model to pull off “complex, multi-step research.” It does this by integrating data from various sources, while “Analyst” processes raw data and executes Python code; which allows it to function like a data scientist. Another tool is DeepSeek’s V3 Model. This is a Chinese AI model that has rapidly emerged as a “notable player” in the global AI landscape in recent months. They’ve accomplished this by showcasing significant improvements in reasoning and coding capabilities. Tools like these, and more, are crucial for code optimization/quality improvement, automated debugging/error detection, faster learning/skill enhancement, enhanced collaboration/documentation, etc.</p>
<div class="page-break">

</div>
</section>
<section id="sources" class="level2">
<h2 class="anchored" data-anchor-id="sources">Sources</h2>
<p>Werner, J. (2024, May 9). AI and the future of coding. Forbes. https://www.forbes.com/sites/johnwerner/2024/01/24/ai-and-the-future-of-coding/</p>
<p>Education, I. (2024, November 25). What is AI code-generation? https://www.ibm.com/think/topics/ai-code-generation</p>
<p>Lawler, R. (2025, March 25). Google says its new ‘reasoning’ Gemini AI models are the best ones yet. The Verge. https://www.theverge.com/news/635502/google-gemini-2-5-reasoning-ai-model​</p>
<p>Lawler, R. (2025, March 26). Microsoft adds ‘deep reasoning’ Copilot AI for research and data analysis. The Verge. https://www.theverge.com/microsoft/636089/microsoft-365-copilot-reasoning-ai-agents</p>
<p>Mo, L., &amp; Goh, B. (2025, March 25). China’s DeepSeek releases AI model upgrade, intensifies rivalry with OpenAI. Reuters. https://www.reuters.com/technology/artificial-intelligence/chinas-deepseek-releases-ai-model-upgrade-intensifies-rivalry-with-openai-2025-03-25/​</p>
<p>Tent, M. (2024, May 1). I compared every AI coding assistant: The Pros and Cons. Medium. https://medium.com/<span class="citation" data-cites="moneytent/i-compared-every-ai-coding-assistant-the-pros-and-cons-ce41f891900e">@moneytent/i-compared-every-ai-coding-assistant-the-pros-and-cons-ce41f891900e</span></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>